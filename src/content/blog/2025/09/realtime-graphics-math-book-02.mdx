---
title: 「リアルタイムグラフィックスの数学」勉強ログ - 第2章疑似乱数
slug: realtime-graphics-math-book-02
pubDate: 2025-09-10
image: ../../../../assets/images/realtime-graphics-math-book-02.jpg
category: プログラミング
tags:
  - シェーダ
  - 数学
  - 勉強ログ
description: 第2章の疑似乱数についての勉強ログ
isAdLink: true
---

import AmazonLink from "@/components/markdown/AmazonLink.astro";
import RecommendLink from "@/components/markdown/RecommendLink.astro";
import WikipediaEmbed from "@/components/markdown/WikipediaEmbed.astro";

## はじめに

「リアルタイムグラフィックスの数学」の第 2 章の疑似乱数についての勉強ログです。

<AmazonLink
  imageId="61CP8Asy52L._SY522_"
  linkId="3Iy0agT"
  title="リアルタイムグラフィックスの数学 ― GLSLではじめるシェーダプログラミング"
  author="巴山竜来"
/>

## レガシー乱数

GLSL ES 1.0 ではビット演算が使えないため、ハッシュ関数ではなくサイン関数を使用した乱数生成が行われていました。The Book of Shaders ではサイン関数を使用した乱数生成の方法が紹介されています。

https://thebookofshaders.com/10/?lan=jp

サイン関数自体には乱数性はないですが、サイン関数の値に大きい値をかけて桁を上げ、`fract`で小数部分を取り出すことで乱数のように見えることができます。

レガシー乱数の 1 変数と 2 変数のコードは次のようになります。

```glsl title="レガシー乱数"
// 1変数のレガシー乱数
float fractSin11(float x) {
  return fract(1000.0 * sin(x));
}

// 2変数のレガシー乱数
float fractSin21(vec2 xy) {
  return fract(sin(dot(xy, vec2(12.9898, 78.233))) * 43758.5453123);
}
```

結果は下図のようになります。

![レガシー乱数の 1 変数と 2 変数の結果](https://res.cloudinary.com/dy8ftemi0/image/upload/v1757260457/realtime-graphics-math-book-02-01_dwxqvh.jpg "レガシー乱数の 1 変数と 2 変数の結果")

2 変数のレガシー乱数で使用しているマジックナンバーは、GLSL で伝統的によく使用されている値になります。

## 符号なし整数の可視化

サンプルコード 2.2 のコードを説明します。このサンプルでは 32 ビットの 2 進数を白黒で可視化しています。ここで 「特定のビットを取り出し」0 か 1 かを判定しているコードは次のようになってます。

```glsl
b = (b << uint(pos.x)) >> 31;
```

分かりやすく考えるために、10 進数で 9 の場合を例としてみましょう。
10 進数で 9 を 32 ビットで表現すると次のようになります。

```
b = 0000 0000 0000 0000 0000 0000 0000 1001
```

4 ビット目の 1 を取得する場合を考えてみましょう。まず$31 -  4 = 27$なので 27 ビット分を左シフトします。

```
b = 0000 0000 0000 0000 0000 0000 0000 1001
b << 27 // 31 - 4
b = 1001 0000 0000 0000 0000 0000 0000 0000
```

これを 31 ビット分を右シフトすることで 4 ビット目の 1 が取得できます。

```
b = 1001 0000 0000 0000 0000 0000 0000 0000
b >> 31
b = 0000 0000 0000 0000 0000 0000 0000 0001
```

サンプルコードではフラグメント範囲の x 座標を 32 に拡大しているので、`uint(pos.x)`を取ることで 32 ビットの 2 進数を白黒で可視化することができています。

## 浮動小数点数のビット列

符号なし整数(uint, unsigned integer)はビット列をそのまま 2 進数変換することで得られます。ですが、負の数や小数部分を含む浮動小数点の場合は、ビット列から数値への変換は自明ではないです。32 ビット浮動小数点は IEEE754 と呼ばれる標準規格があり、highp 精度ではこれに準拠して変換されます。

IEEE754 では、32 ビットの情報を$b_0...b_{31}$の 2 進数で表したとき、符号部$b_0$、指数部$b_1...b_8$、仮数部$b_9...b_{31}$のように分けて、$c = b_1...b_8$としたときに次のように計算します。

$$
(-1)^{b_0} \times 2^{c-127} \times 1.b_9...b_{31}
$$

書籍の例として 11.5625 の浮動小数点を符号なし整数に変換してみましょう。
整数部分の 11 を 2 進数に変換すると 1011 になります。小数部分の 0.5625 を 2 進数に変換すると 0.1001 になります。これを計算式に合うように整数部分に 1 が来るように$2^3$かけて右にずらします。

$$
11.5625 = 1011.1001 = 1.0111001 \times 2^3
$$

この$01110010...0$が仮数部になります。符号部に関しては、正の数なので$b_0$は $0$ になります。

最後に指数部に関しては、$c - 127 = 3$なので$c=130$になり、$130$を 2 進数で表すと$10000010$になるのでこの値が指数部になります。

結果として、11.5625 の符号なし整数は下記になります。

```
0 10000010 0111001...0
```

GLSL ではビット列としての浮動小数点を符号なし整数に変換する関数として、`floatBitsToUint`関数が組み込まれています。

## ハッシュ関数

ハッシュ関数による乱数生成法については、難しかったので機会があれば調べる予定。

書籍で紹介されていた、Jarzynski-Olano の約 30 ものハッシュ関数についてのコストパフォマンスについての論文[Hash Functions for GPU Rendering - Jarzynski-Olano](https://jcgt.org/published/0009/03/02/paper.pdf)

Shadertoy での実装については[こちら](https://www.shadertoy.com/view/XlGcRh)

## 次回リンク

<RecommendLink
  items={[
    {
      title: "「リアルタイムグラフィックスの数学」勉強ログ - 第3章値ノイズ",
      link: "realtime-graphics-math-book-03",
      image: "realtime-graphics-math-book-03.jpg",
    },
  ]}
/>

## 後で詳しく調べるものリスト

- ハッシュ関数のアルゴリズム

  <WikipediaEmbed title="ハッシュ関数" />

- Xorshift による乱数生成法

  <WikipediaEmbed title="Xorshift" />

- bit 演算お絵描き
  参考
  [【GLSL】bit 演算お絵描き](https://qiita.com/nemutas/items/e8dc2ef165950ae14708)

- [XOR Texture](https://lodev.org/cgtutor/xortexture.html)

## 参考書籍

<AmazonLink
  imageId="61CP8Asy52L._SY522_"
  linkId="3Iy0agT"
  title="リアルタイムグラフィックスの数学 ― GLSLではじめるシェーダプログラミング"
  author="巴山竜来"
/>
